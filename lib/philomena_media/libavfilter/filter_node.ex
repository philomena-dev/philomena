defprotocol PhilomenaMedia.Libavfilter.FilterNode do
  @doc """
  The name of this filter, as a string, or nil if the filter is an endpoint.
  """
  @spec name(t) :: String.t() | nil
  def name(t)

  @doc """
  A list of options passed to this filter, if any.

  ## Example

      iex> FilterNode.opts(%Paletteuse{...})
      [dither: :bayer, bayer_scale: 5]

  """
  @spec opts(t) :: keyword()
  def opts(t)

  @type pad_name :: atom()
  @type pad_type :: :video
  @type pad_list :: [{pad_name(), pad_type()}]

  @doc """
  A list of inputs passed to this filter, if any.

  > #### Info {: .info}
  >
  > Inputs are given names for clarity, but libavfilter addresses inputs
  > by *numeric index*, not by name, so this must not be placed into a map.

  ## Example

      iex> FilterNode.inputs(%Paletteuse{...})
      [source: :video, palette: :video]
  """
  @spec inputs(t) :: pad_list()
  def inputs(t)

  @doc """
  A list of outputs generated by this filter, if any.

  > #### Info {: .info}
  >
  > Outputs are given names for clarity, but libavfilter addresses outputs
  > by *numeric index*, not by name, so this must not be placed into a map.

  ## Example

      iex> FilterNode.outputs(%Scale{...})
      [result: :video]
  """
  @spec outputs(t) :: pad_list()
  def outputs(t)
end

defimpl PhilomenaMedia.Libavfilter.FilterNode, for: Any do
  def name(t), do: t.name
  def opts(t), do: t.opts
  def inputs(t), do: t.inputs
  def outputs(t), do: t.outputs
end
